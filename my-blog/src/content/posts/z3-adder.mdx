---
title: 'z3-加法器实验'
date: '2024-05-25'
description: '补码的加法其实就是将两个补码形式的二进制数字直接相加，处理的时候忽略超出固定位数的进位。补码的加法运算和无符号二进制数的加法操作一样，不需要额外处理负号或减法的逻辑。'
tags: ['计算机组成原理']

---
# 补码器加减法，运算方法简介
**我们要知道什么是补码的加法，我们为什么要用补码的加法？**
> 补码的加法其实就是将两个补码形式的二进制数字直接相加，处理的时候忽略超出固定位数的进位。补码的加法运算和无符号二进制数的加法操作一样，不需要额外处理负号或减法的逻辑

**补码加法的具体操作步骤**：

1. 将两个补码数位对齐（确保位数一致）
2. 诸位相加，处理进位
3. 如果结果超出固定的位数，忽略超出部分的进位

例子：
假如我们在一个8位的系统中进行加法计算

- 5+3
   - 5的补码：00000101
   - 3的补码：00000011
   - 00001000（结果位8）
- 5+(-3)
   - 5的补码：00000101
   - -3的补码：11111101
   - 相加：10000010（结果位-2，最高位1表示结果是负数）

那么我们为什么要使用补码的加法？
> 补码的使用简化了计算机硬件的设计，使有符号的整数运算变得更加高效统一。补码的使用还简化了负数的表示和处理，使计算机更方便地进行各种数值运算。

在了解了补码的加法之后我们就可以尝试设计一位全加器电路了
# 构造一个一位全加器
首先要知道什么是全加器？
> 全加器是一种基本的数字电路，用于二进制数的加法运算。它能够同时处理两个二进制数的加法运算。它能够同时处理两个二进制位和一个来自低位的进位输入，并输出该位的和以及进位到高位的值。全加器是构建多位二进制加法器的基本模块。

## 全加器的功能
全加器有三个输入两个输出：

- 输入：两个被加的二进制位A和B，以及来自前一位的进位输入C_in_
- 输出：该位的和S和向更高位传递的进位输出C_out_
## 全加器的真值表
| A | B | C_in_ | S | C_out_ |
| --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

## 全加器的逻辑表达式
根据真值表，全加器的输入S和输出C可以用逻辑表达式表示：

- 和（sum）S：S = A XOR B XOR C_in_
- 进位（Carry）C_out_：C_out_ = (A * B) + (B * C_in_) + (A * C_in_)
## 一位全加器的电路实现
如下图所示：
![image.png](/images/image_png_dfacb7db89d8.png)
**功能封装**
![image.png](/images/image_png_c70771da3708.png)
# 八位串行加法器
> 八位串行加法器是一种可以对两个8位二进制数进行加法运算的电路，串行加法器的工作原理是每次处理一个位，并将进位传递到下一位进行累加。以下是八位串行加法器的详细电路设计和验证。

## 电路设计

- **全加器**：用于对两个二进制位及一个进位进行相加。
- **移位寄存器**：用于存储和移位操作，分别存储两个8位数加数和结果
- **D触发器：**用于存储和传递进位
- **时钟**：用于同步操作
## 电路示意图
![image.png](/images/image_png_385cef9d8a85.png)
## 使用具体数字验证
#### 1. 初始化

- A寄存器：10101010
- B寄存器：01010101
- 进位 𝐶0：0
#### 2. 逐位相加

1. **第1次时钟脉冲**：
   - 取出最低位：A0 = 0, B0 = 1, 𝐶0=0
   - 全加器计算：𝑆0=0⊕1⊕0=1
   - 进位：𝐶1=(0⋅1)+(1⋅0)+(0⋅0)=0
   - 移位：A -> 01010101, B -> 00101010
2. **第2次时钟脉冲**：
   - 取出当前位：A1 = 1, B1 = 0, 𝐶1=0
   - 全加器计算：𝑆1=1⊕0⊕0=1
   - 进位：𝐶2=(1⋅0)+(0⋅0)+(1⋅0)=0
   - 移位：A -> 00101010, B -> 00010101
3. **第3次时钟脉冲**：
   - 取出当前位：A2 = 0, B2 = 1, 𝐶2=0
   - 全加器计算：𝑆2=0⊕1⊕0=1
   - 进位：𝐶3=(0⋅1)+(1⋅0)+(0⋅0)=0
   - 移位：A -> 00010101, B -> 00001010
4. **第4次时钟脉冲**：
   - 取出当前位：A3 = 1, B3 = 0, 𝐶3=0
   - 全加器计算：𝑆3=1⊕0⊕0=1
   - 进位：𝐶4=(1⋅0)+(0⋅0)+(1⋅0)=0
   - 移位：A -> 00001010, B -> 00000101
5. **第5次时钟脉冲**：
   - 取出当前位：A4 = 0, B4 = 1, 𝐶4=0
   - 全加器计算：𝑆4=0⊕1⊕0=1
   - 进位：𝐶5=(0⋅1)+(1⋅0)+(0⋅0)=0
   - 移位：A -> 00000101, B -> 00000010
6. **第6次时钟脉冲**：
   - 取出当前位：A5 = 1, B5 = 0, 𝐶5=0
   - 全加器计算：𝑆5=1⊕0⊕0=1
   - 进位：𝐶6=(1⋅0)+(0⋅0)+(1⋅0)=0
   - 移位：A -> 00000010, B -> 00000001
7. **第7次时钟脉冲**：
   - 取出当前位：A6 = 0, B6 = 1, 𝐶6=0
   - 全加器计算：𝑆6=0⊕1⊕0=1
   - 进位：𝐶7=(0⋅1)+(1⋅0)+(0⋅0)=0
   - 移位：A -> 00000001, B -> 00000000
8. **第8次时钟脉冲**：
   - 取出当前位：A7 = 1, B7 = 0, 𝐶7=0
   - 全加器计算：𝑆7=1⊕0⊕0=1
   - 进位：𝐶8=(1⋅0)+(0⋅0)+(1⋅0)=0
### 结果
最终输出结果的各位和为 𝑆7𝑆6𝑆5𝑆4𝑆3𝑆2𝑆1𝑆0=11111111，即十进制的255。进位输出 𝐶8=0，表示没有产生进位。
![image.png](/images/image_png_c74d0db894f4.png)
# 八位可控加减法器
> 8位可控加减法器是一种能够对两个8位二进制数进行加法或减法运算的电路。它通过控制信号来决定是执行加法还是减法。减法可以通过将被减数取补码并进行加法来实现。以下是详细的电路设计和使用具体数字进行验证的步骤。

## 电路设计

- **全加器**：用于对两个二进制位及一个进位进行相加。
- **移位寄存器**：用于存储和移位操作，分别存储两个八位数和结果。
- **D触发器**：用于存储和传递进位。
- **时钟**：用于同步操作。
- **异或门**：用于将减法操作转化为加法操作。
- **控制信号**：用于选择加法或减法操作。
## 电路示意图
![image.png](/images/image_png_38d983666448.png)
## 使用具体数字验证
### 加法验证
假设我们要相加的两个8位数是：

- A = 01101101 (十进制的109)
- B = 00111011 (十进制的59)
1. **初始化**：
   - A寄存器：01101101
   - B寄存器：00111011
   - 进位 _C_0：0
   - 控制信号 Add/Sub = 0（加法）
2. **逐位相加**
- **第1次时钟脉冲**：
   - 取出最低位：A0 = 1, B0 = 1, 𝐶0=0
   - 全加器计算：𝑆0=1⊕1⊕0=0
   - 进位：𝐶1=(1⋅1)+(1⋅0)+(0⋅0)=1
   - 移位：A -> 00110110, B -> 00011101
- **第2次时钟脉冲**：
   - 取出当前位：A1 = 0, B1 = 1, 𝐶1=1
   - 全加器计算：𝑆1=0⊕1⊕1=0
   - 进位：𝐶2=(0⋅1)+(1⋅1)+(0⋅1)=1
   - 移位：A -> 00011011, B -> 00001110
- **第3次时钟脉冲**：
   - 取出当前位：A2 = 1, B2 = 1, 𝐶2=1
   - 全加器计算：𝑆2=1⊕1⊕1=1
   - 进位：𝐶3=(1⋅1)+(1⋅1)+(1⋅1)=1
   - 移位：A -> 00001101, B -> 00000111
- **第4次时钟脉冲**：
   - 取出当前位：A3 = 1, B3 = 0, 𝐶3=1
   - 全加器计算：𝑆3=1⊕0⊕1=0
   - 进位：𝐶4=(1⋅0)+(0⋅1)+(1⋅1)=1
   - 移位：A -> 00000110, B -> 00000011
- **第5次时钟脉冲**：
   - 取出当前位：A4 = 0, B4 = 1, 𝐶4=1
   - 全加器计算：𝑆4=0⊕1⊕1=0
   - 进位：𝐶5=(0⋅1)+(1⋅1)+(0⋅1)=1
   - 移位：A -> 00000011, B -> 00000001
- **第6次时钟脉冲**：
   - 取出当前位：A5 = 1, B5 = 1, 𝐶5=1
   - 全加器计算：𝑆5=1⊕1⊕1=1
   - 进位：𝐶6=(1⋅1)+(1⋅1)+(1⋅1)=1
   - 移位：A -> 00000001, B -> 00000000
- **第7次时钟脉冲**：
   - 取出当前位：A6 = 0, B6 = 0, 𝐶6=1
   - 全加器计算：𝑆6=0⊕0⊕1=1
   - 进位：𝐶7=(0⋅0)+(0⋅1)+(0⋅1)=0
   - 移位：A -> 00000000, B -> 00000000
- **第8次时钟脉冲**：
   - 取出当前位：A7 = 0, B7 = 0, 𝐶7=0
   - 全加器计算：𝑆7=0⊕0⊕0=0
   - 进位：𝐶8=(0⋅0)+(0⋅0)+(0⋅0)=0
#### 结果
最终输出结果的各位和为 𝑆7𝑆6𝑆5𝑆4𝑆3𝑆2𝑆1𝑆0=10101000，即十进制的168。
![image.png](/images/image_png_88be69fe4e62.png)
### 减法验证
#### 初始化

- A寄存器：01101101
- B寄存器：00111011
- 进位 _C_0：1（由于使用补码减法，初始进位为1）
- 控制信号 Add/Sub = 1（减法）
#### 逐位计算（将B取反再加上A）

1. **第1次时钟脉冲**：
   - 取出最低位：A0 = 1, B0 = 1
   - 由于控制信号为1，B0取反：B0' = 0
   - 全加器计算：𝑆0=1⊕0⊕1=0
   - 进位：𝐶1=(1⋅0)+(0⋅1)+(1⋅1)=1
   - 移位：A -> 00110110, B -> 00011101
2. **第2次时钟脉冲**：
   - 取出当前位：A1 = 0, B1 = 1
   - 由于控制信号为1，B1取反：B1' = 0
   - 全加器计算：𝑆1=0⊕0⊕1=1
   - 进位：𝐶2=(0⋅0)+(0⋅1)+(0⋅1)=0
   - 移位：A -> 00011011, B -> 00001110
3. **第3次时钟脉冲**：
   - 取出当前位：A2 = 1, B2 = 1
   - 由于控制信号为1，B2取反：B2' = 0
   - 全加器计算：𝑆2=1⊕0⊕0=1
   - 进位：𝐶3=(1⋅0)+(0⋅0)+(1⋅0)=0
   - 移位：A -> 00001101, B -> 00000111
4. **第4次时钟脉冲**：
   - 取出当前位：A3 = 1, B3 = 0
   - 由于控制信号为1，B3取反：B3' = 1
   - 全加器计算：𝑆3=1⊕1⊕0=0
   - 进位：𝐶4=(1⋅1)+(1⋅0)+(1⋅0)=1
   - 移位：A -> 00000110, B -> 00000011
5. **第5次时钟脉冲**：
   - 取出当前位：A4 = 0, B4 = 1
   - 由于控制信号为1，B4取反：B4' = 0
   - 全加器计算：𝑆4=0⊕0⊕1=1
   - 进位：𝐶5=(0⋅0)+(0⋅1)+(0⋅1)=0
   - 移位：A -> 00000011, B -> 00000001
6. **第6次时钟脉冲**：
   - 取出当前位：A5 = 1, B5 = 0
   - 由于控制信号为1，B5取反：B5' = 1
   - 全加器计算：𝑆5=1⊕1⊕0=0
   - 进位：𝐶6=(1⋅1)+(1⋅0)+(0⋅0)=1
   - 移位：A -> 00000001, B -> 00000000
7. **第7次时钟脉冲**：
   - 取出当前位：A6 = 0, B6 = 0
   - 由于控制信号为1，B6取反：B6' = 1
   - 全加器计算：𝑆6=0⊕1⊕1=0
   - 进位：𝐶7=(0⋅1)+(1⋅1)+(0⋅1)=0
   - 移位：A -> 00000000, B -> 00000000
8. **第8次时钟脉冲**：
   - 取出当前位：A7 = 0, B7 = 0
   - 由于控制信号为1，B7取反：B7' = 1
   - 全加器计算：𝑆7=0⊕1⊕0=1
   - 进位：𝐶8=(0⋅1)+(1⋅0)+(0⋅0)=0
#### 结果
最终输出结果的各位和为 𝑆7𝑆6𝑆5𝑆4𝑆3𝑆2𝑆1𝑆0=00110010，即十进制的50。
![image.png](/images/image_png_09d053ada282.png)
